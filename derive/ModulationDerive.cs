using System.Text;
using Microsoft.CodeAnalysis;

namespace AUTD3Sharp.Derive;

[Generator(LanguageNames.CSharp)]
public partial class ModulationDeriveGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "AUTD3Sharp.Derive.ModulationAttribute",
            static (node, token) => true,
            static (context, token) => context);

        context.RegisterSourceOutput(source, Emit);
    }
    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        var attribute = source.Attributes.First(attr => attr!.AttributeClass!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                                                        "global::AUTD3Sharp.Derive.ModulationAttribute");
        var namedArguments = attribute.NamedArguments;
        var noCache = namedArguments.Any(arg => arg.Key == "NoCache" && (bool)(arg.Value.Value ?? false));
        var noRadiationPressure = namedArguments.Any(arg => arg.Key == "NoRadiationPressure" && (bool)(arg.Value.Value ?? false));
        var noTransform = namedArguments.Any(arg => arg.Key == "NoTransform" && (bool)(arg.Value.Value ?? false));
        var configNoChange = namedArguments.Any(arg => arg.Key == "ConfigNoChange" && (bool)(arg.Value.Value ?? false));

        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace ? "" : $"namespace {typeSymbol.ContainingNamespace}";

        var cacheCode = noCache ? "" :
            $$"""
              
        public AUTD3Sharp.Driver.Datagram.Modulation.Cache<{{typeName}}> WithCache()
        {
            return new AUTD3Sharp.Driver.Datagram.Modulation.Cache<{{typeName}}>(this);
        }

""";
        var radiationPressureCode = noRadiationPressure ? "" :
            $$"""
              
        public AUTD3Sharp.Driver.Datagram.Modulation.RadiationPressure<{{typeName}}> WithRadiationPressure()
        {
            return new AUTD3Sharp.Driver.Datagram.Modulation.RadiationPressure<{{typeName}}>(this);
        }

""";

        var transformCode = noTransform ? "" :
            $$"""
              
        public AUTD3Sharp.Driver.Datagram.Modulation.Transform<{{typeName}}> WithTransform(Func<int, EmitIntensity, EmitIntensity> f)
        {
            return new AUTD3Sharp.Driver.Datagram.Modulation.Transform<{{typeName}}>(this, f);
        }

""";

        var configCode = configNoChange ? "" :
            $$"""
              
        public {{typeName}} WithSamplingConfig(SamplingConfiguration config)
        {
            Config = config;
            return this;
        }

""";

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
        var code = $$"""
// <auto-generated/>
#nullable enable

using System;

{{ns}} {
    partial class {{typeName}}
    {
{{cacheCode}}
{{configCode}}
{{radiationPressureCode}}
{{transformCode}}

        /// <summary>
        /// Set loop behavior
        /// </summary>
        /// <param name="loopBehavior">loop behavior</param>
        /// <returns></returns>
        public {{typeName}} WithLoopBehavior(LoopBehavior loopBehavior)
        {
            LoopBehavior = loopBehavior;
            return this;
        }
    }
}
""";
        context.AddSource($"{fullType}.ModulationDerive.g.cs", code);
    }
}