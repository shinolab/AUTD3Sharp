using System.Text;
using Microsoft.CodeAnalysis;

namespace AUTD3Sharp.Derive;

[Generator(LanguageNames.CSharp)]
public partial class GainDeriveGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            "AUTD3Sharp.Derive.GainAttribute",
            static (node, token) => true,
            static (context, token) => context);

        context.RegisterSourceOutput(source, Emit);
    }
    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        var attribute = source.Attributes.First(attr => attr!.AttributeClass!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ==
                                                        "global::AUTD3Sharp.Derive.GainAttribute");
        var namedArguments = attribute.NamedArguments;
        var noCache = namedArguments.Any(arg => arg.Key == "NoCache" && (bool)(arg.Value.Value ?? false));
        var noTransform = namedArguments.Any(arg => arg.Key == "NoTransform" && (bool)(arg.Value.Value ?? false));

        var isCustom = typeSymbol.GetMembers("Calc").Length != 0;

        var ns = typeSymbol.ContainingNamespace.IsGlobalNamespace ? "" : $"namespace {typeSymbol.ContainingNamespace}";

        var customCode = isCustom ?
            $$"""
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        private unsafe delegate void GainDelegate(IntPtr context, GeometryPtr geometryPtr, ushort devIdx, byte trIdx, AUTD3Sharp.NativeMethods.Drive* dst);

        private GainDelegate _f = null;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private GainPtr GainPtr(Geometry geometry)
        {
            unsafe{
                var f = Calc(geometry);
                _f = (context, geometryPtr, devIdx, trIdx, dst) =>
                {   
                    var devPtr = NativeMethodsBase.AUTDDevice(geometryPtr, devIdx);
                    var dev = ((AUTD3Sharp.Driver.Datagram.Gain.IGain)this).GetDevice(devIdx, geometryPtr);
                    var tr = ((AUTD3Sharp.Driver.Datagram.Gain.IGain)this).GetTransducer(trIdx, devPtr);
                    var d = f(dev)(tr);
                    dst->intensity = d.Intensity.Value;
                    dst->phase = d.Phase.Value;
                };

                return NativeMethodsBase.AUTDGainCustom(new ConstPtr { Item1 = Marshal.GetFunctionPointerForDelegate(_f) }, new ConstPtr { Item1 = IntPtr.Zero }, ((AUTD3Sharp.Driver.Datagram.Gain.IGain)this).GetGeometryPtr(geometry));
            }
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ExcludeFromCodeCoverage] private static Func<Device, Func<Transducer, AUTD3Sharp.Drive>> Transform(Func<Device, Func<Transducer, AUTD3Sharp.Drive>> f)
        {
            return f;
        }

""" : "";

        var cacheCode = noCache ? "" :
            $$"""
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ExcludeFromCodeCoverage] public AUTD3Sharp.Driver.Datagram.Gain.Cache<{{typeName}}> WithCache()
        {
            return new AUTD3Sharp.Driver.Datagram.Gain.Cache<{{typeName}}>(this);
        }

""";
        var transformCode = noTransform ? "" :
            $$"""
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ExcludeFromCodeCoverage] public AUTD3Sharp.Driver.Datagram.Gain.Transform<{{typeName}}> WithTransform(Func<Device, Func<AUTD3Sharp.Transducer, AUTD3Sharp.Drive, AUTD3Sharp.Drive>> f)
        {
            return new AUTD3Sharp.Driver.Datagram.Gain.Transform<{{typeName}}>(this, f);
        }

""";

        var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
        var nsBegin = ns == "" ? "" : $"{ns} {{";
        var nsEnd = ns == "" ? "" : "}";
        var code = $$"""
// <auto-generated/>

#if UNITY_2020_2_OR_NEWER
#nullable enable
#endif

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using AUTD3Sharp;
using AUTD3Sharp.Driver.Datagram;
using AUTD3Sharp.NativeMethods;

{{nsBegin}}
    public partial class {{typeName}} : AUTD3Sharp.Driver.Datagram.Gain.IGain, IDatagramS<GainPtr>, IDatagram
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        DatagramPtr IDatagram.Ptr(Geometry geometry) => NativeMethodsBase.AUTDGainIntoDatagram(((AUTD3Sharp.Driver.Datagram.Gain.IGain)this).GainPtr(geometry));
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ExcludeFromCodeCoverage] 
        DatagramPtr IDatagramS<GainPtr>.IntoSegment(GainPtr p, Segment segment, bool updateSegment) => NativeMethodsBase.AUTDGainIntoDatagramWithSegment(p, segment, updateSegment);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ExcludeFromCodeCoverage] 
        GainPtr IDatagramS<GainPtr>.RawPtr(Geometry geometry) => GainPtr(geometry);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        GainPtr AUTD3Sharp.Driver.Datagram.Gain.IGain.GainPtr(Geometry geometry) => GainPtr(geometry);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [ExcludeFromCodeCoverage] 
        public DatagramWithSegment<{{typeName}}, GainPtr> WithSegment(Segment segment, bool updateSegment) => new DatagramWithSegment<{{typeName}}, GainPtr>(this, segment, updateSegment);

{{customCode}}
{{cacheCode}}
{{transformCode}}
    }
{{nsEnd}}
""";
        context.AddSource($"{fullType}.GainDerive.g.cs", code);
    }
}
